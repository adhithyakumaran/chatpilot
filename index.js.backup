/**
 * index.js - FIXED VERSION
 * âœ… Auto QR regeneration on disconnect
 * âœ… Proper connection state management
 * âœ… Fixed reconnection loops
 * âœ… Better inbox message handling
 * âœ… Timeout error handling
 * âœ… Fixed database path for frontend compatibility
 * âœ… Media sending from inbox (downloads from R2 first with URL validation)
 * âœ… Fixed /upload endpoint to actually upload to R2
 * âœ… Updated to use 'tenants' collection instead of 'companies'
 */

require("dotenv").config();
const express = require("express");
const cors = require("cors");
const {
    default: makeWASocket,
    DisconnectReason,
    useMultiFileAuthState,
    fetchLatestBaileysVersion,
    downloadMediaMessage
} = require("@whiskeysockets/baileys");

const admin = require("firebase-admin");
const pino = require("pino");
const fs = require("fs");
const qrcode = require("qrcode-terminal");
const { GoogleGenerativeAI } = require("@google/generative-ai");
const pdfParse = require("pdf-parse");
const axios = require("axios"); // âœ… For downloading media from R2

const sessions = require("./sessions");
const { uploadMedia } = require("./storage_r2");

// ---------------- CONFIGURATION ----------------
const PORT = process.env.PORT || 3000;
const SERVER_API_KEY = process.env.SERVER_API_KEY || "chatpilot-secret-key-123";
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

// âœ… NEW: Track reconnection attempts
const reconnectAttempts = new Map();
const MAX_RECONNECT_ATTEMPTS = 5;
const RECONNECT_DELAY = 5000; // 5 seconds

// Initialize AI
let aiModel = null;
if (GEMINI_API_KEY) {
    const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
    aiModel = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
    console.log("âœ… AI Model Initialized");
} else {
    console.warn("âš ï¸ GEMINI_API_KEY missing! Auto-replies will not work.");
}

// ---------------- FIREBASE INIT ----------------
const serviceAccount = require("./serviceAccountKey.json");

if (!admin.apps.length) {
    admin.initializeApp({
        credential: admin.credential.cert(serviceAccount)
    });
}
const db = admin.firestore();

// ---------------- EXPRESS API ----------------
const app = express();
app.use(cors({ origin: '*' }));
app.use(express.json());
app.use(express.raw({ type: ['application/octet-stream', 'application/pdf'], limit: '50mb' }));

// âœ… FIXED UPLOAD ENDPOINT
app.put("/upload/:uid/:filename", async (req, res) => {
    try {
        if (req.headers['x-api-key'] !== SERVER_API_KEY) return res.status(403).send("Forbidden");
        const { uid, filename } = req.params;
        const fileBuffer = req.body;
        if (!fileBuffer || fileBuffer.length === 0) return res.status(400).send("No file data");

        console.log(` Uploading: ${filename}`);

        // Determine mime type based on extension (basic check)
        const ext = filename.split('.').pop().toLowerCase();
        let mimeType = 'application/octet-stream';
        if (['jpg', 'jpeg'].includes(ext)) mimeType = 'image/jpeg';
        else if (ext === 'png') mimeType = 'image/png';
        else if (ext === 'mp4') mimeType = 'video/mp4';
        else if (ext === 'pdf') mimeType = 'application/pdf';

        // âœ… Upload to R2
        const publicUrl = await uploadMedia(uid, filename, fileBuffer, mimeType);
        console.log(`âœ… Uploaded to R2: ${publicUrl}`);

        res.status(200).send(publicUrl);
    } catch (e) {
        console.error("Upload Error:", e);
        res.status(500).send("Error");
    }
});

// âœ… Manual Session Start
app.post("/start-session/:uid", async (req, res) => {
    try {
        const { uid } = req.params;
        console.log(`ðŸ”„ Manual session start requested for ${uid}`);
        await startSession(uid);
        res.status(200).send({ success: true, message: "Session started" });
    } catch (e) {
        console.error("Session Start Error:", e);
        res.status(500).send({ success: false, error: e.message });
    }
});

// âœ… NEW: Manual Disconnect & QR Reset
app.post("/disconnect/:uid", async (req, res) => {
    try {
        const { uid } = req.params;
        console.log(`ðŸ”Œ Manual disconnect requested for ${uid}`);

        const sock = sessions.get(uid);
        if (sock) {
            await sock.logout();
            sessions.delete(uid);
        }

        // Delete auth files
        const authPath = `auth_info_${uid}`;
        if (fs.existsSync(authPath)) {
            fs.rmSync(authPath, { recursive: true, force: true });
        }

        // Reset DB status
        await updateDB(uid, { status: "disconnected", qr: null });

        // Start fresh session with new QR
        setTimeout(() => startSession(uid), 2000);

        res.status(200).send({ success: true, message: "Disconnected, generating new QR..." });
    } catch (e) {
        console.error("Disconnect Error:", e);
        res.status(500).send({ success: false, error: e.message });
    }
});

app.listen(PORT, () => console.log(`ðŸ”¥ Server running on port ${PORT}`));

// ---------------- WHATSAPP LOGIC ----------------

// âœ… IMPROVED: Auto-Restore Sessions
(async () => {
    const snaps = await db.collection("tenants").get();
    for (const doc of snaps.docs) {
        const wa = doc.data().integrations?.whatsapp;
        if (wa && wa.status === 'connected') {
            await new Promise(resolve => setTimeout(resolve, 2000)); // Stagger startup
            startSession(doc.id);
        }
    }
})();

db.collection("server_config").doc("active_company").onSnapshot(s => {
    if (s.exists && !sessions.has(s.data().uid)) startSession(s.data().uid);
});

async function startSession(uid) {
    if (sessions.has(uid)) {
        console.log(`â­ï¸ Session already running: ${uid}`);
        return;
    }

    console.log(`ðŸš€ Starting socket: ${uid}`);

    const authPath = `auth_info_${uid}`;
    const { state, saveCreds } = await useMultiFileAuthState(authPath);
    const { version } = await fetchLatestBaileysVersion();

    const sock = makeWASocket({
        version,
        logger: pino({ level: "silent" }),
        auth: state,
        printQRInTerminal: false,
        browser: ["ChatPilot", "Chrome", "1.0"],
        syncFullHistory: false,
        connectTimeoutMs: 60000,
        defaultQueryTimeoutMs: 60000, // âœ… INCREASED TIMEOUT
        retryRequestDelayMs: 500,
        maxMsgRetryCount: 3,
        sock.ev.on("messages.upsert", async (m) => {
            const msg = m.messages[0];
            if (!msg.message || msg.key.fromMe) return;
            if (msg.key.remoteJid === "status@broadcast") return;

            const jid = msg.key.remoteJid;
            const contactPhone = jid.split('@')[0];

            let text = msg.message.conversation || msg.message.extendedTextMessage?.text || "";
            let mediaType = null;
            let mimeType = null;
            let fileName = null;

            if (msg.message.imageMessage) {
                mediaType = "image";
                text = msg.message.imageMessage.caption || "ðŸ“· Image";
                mimeType = msg.message.imageMessage.mimetype;
                fileName = `image_${Date.now()}.jpg`;
            } else if (msg.message.videoMessage) {
                mediaType = "video";
                text = msg.message.videoMessage.caption || "ðŸŽ¥ Video";
                mimeType = msg.message.videoMessage.mimetype;
                fileName = `video_${Date.now()}.mp4`;
            } else if (msg.message.documentMessage) {
                mediaType = "document";
                text = msg.message.documentMessage.caption || msg.message.documentMessage.fileName || "ðŸ“„ Document";
                mimeType = msg.message.documentMessage.mimetype;
                fileName = msg.message.documentMessage.fileName || `doc_${Date.now()}`;
            }

            if (!text && !mediaType) return;
            console.log(`ðŸ“© Incoming (${jid}): ${text} [${mediaType || 'text'}]`);

            try {
                const inboxRef = db.collection("tenants").doc(uid).collection("inbox");
                let chatId;

                const chatQuery = await inboxRef.where("contactPhone", "==", contactPhone).limit(1).get();

                if (chatQuery.empty) {
                    const newChat = await inboxRef.add({
                        contactName: msg.pushName || contactPhone,
                        contactPhone: contactPhone,
                        lastMessage: text,
                        unreadCount: 1,
                        status: "open",
                        isGroup: jid.endsWith('@g.us'),
                        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
                        createdAt: admin.firestore.FieldValue.serverTimestamp(),
                    });
                    chatId = newChat.id;
                } else {
                    chatId = chatQuery.docs[0].id;
                    await inboxRef.doc(chatId).update({
                        lastMessage: text,
                        unreadCount: admin.firestore.FieldValue.increment(1),
                        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
                    });
                }

                // ðŸ“¥ DOWNLOAD MEDIA IF PRESENT
                let mediaUrl = null;
                if (mediaType) {
                    try {
                        console.log("ðŸ“¥ Downloading media...");
                        const buffer = await downloadMediaMessage(
                            msg,
                            'buffer',
                            {},
                            {
                                logger: pino({ level: 'silent' }),
                                reuploadRequest: sock.updateMediaMessage
                            }
                        );
                        console.log("ðŸ“¤ Uploading to R2...");
                        mediaUrl = await uploadMedia(uid, fileName, buffer, mimeType);
                        console.log("âœ… Media uploaded:", mediaUrl);
                    } catch (err) {
                        console.error("Media error:", err.message);
                        text += " (Media failed)";
                    }
                }

                // SAVE MESSAGE
                const messageData = {
                    text: text,
                    isMe: false,
                    createdAt: admin.firestore.FieldValue.serverTimestamp(),
                    status: "delivered"
                };

                if (mediaUrl) {
                    messageData.mediaUrl = mediaUrl;
                    messageData.mediaType = mediaType;
                }

                await inboxRef.doc(chatId).collection("messages").add(messageData);

                // AI AUTO-REPLY
                if (aiModel && !mediaType) {
                    try {
                        const doc = await db.collection("tenants").doc(uid).get();
                        const config = doc.data()?.ai_config || {};

                        const kb = config.knowledge_base || "No info provided.";
                        const name = config.business_name || "Support";
                        const phone = config.support_phone || "No phone provided";

                        const prompt = `
                    You are ${name}'s AI assistant.
                    Knowledge: "${kb}"
                    Instructions: Answer briefly based on knowledge. If unsure, say: "Contact us at ${phone}"
                    User: ${text}
                    `;

                        const result = await aiModel.generateContent(prompt);
                        const replyText = result.response.text();

                        console.log(`ðŸ¤– AI Reply: ${replyText}`);

                        const sent = await sock.sendMessage(jid, { text: replyText });

                        await inboxRef.doc(chatId).collection("messages").add({
                            text: replyText,
                            isMe: true,
                            createdAt: admin.firestore.FieldValue.serverTimestamp(),
                            status: "sent",
                            waMessageId: sent.key.id
                        });

                        await inboxRef.doc(chatId).update({
                            lastMessage: replyText,
                            updatedAt: admin.firestore.FieldValue.serverTimestamp(),
                        });
                    } catch (aiErr) {
                        console.error("AI Error:", aiErr.message);
                    }
                }

            } catch (err) {
                console.error("Message Handler Error:", err.message);
            }
        });

        // Real-time Ticks
        sock.ev.on("messages.update", async (updates) => {
            for (const u of updates) {
                if (u.update.status) {
                    const statusMap = { 3: "sent", 4: "delivered", 5: "read" };
                    const newStatus = statusMap[u.update.status];
                    if (newStatus) {
                        try {
                            const q = await db.collectionGroup("messages").where("waMessageId", "==", u.key.id).get();
                            q.forEach(d => d.ref.update({ status: newStatus }));
                        } catch (e) { }
                    }
                }
            }
        });
    }

// âœ… FIXED: Write to subcollection path that frontend expects
async function updateDB(uid, data) {
            await db.collection("tenants").doc(uid).collection("integrations").doc("whatsapp").set(data, { merge: true });
        }

// ---------------- âœ… IMPROVED INBOX OUTGOING LISTENER WITH MEDIA FIX ----------------
console.log("ðŸŽ§ Inbox Listener Active...");

    db.collectionGroup("messages")
        .where("status", "==", "pending")
        .where("isMe", "==", true)
        .onSnapshot(snap => {
            snap.docChanges().forEach(async change => {
                if (change.type !== "added") return;

                const doc = change.doc;
                const data = doc.data();

                const pathSegments = doc.ref.path.split('/');
                if (pathSegments.length < 4) return;
                const uid = pathSegments[1];

                const sock = sessions.get(uid);

                // âœ… BETTER SOCKET CHECK
                if (!sock) {
                    console.log(`âŒ No socket for ${uid}`);
                    await doc.ref.update({ status: "failed", error: "WhatsApp not connected" });
                    return;
                }

                if (!sock.user) {
                    console.log(`â³ Socket not authenticated for ${uid}`);
                    await doc.ref.update({ status: "failed", error: "WhatsApp not authenticated" });
                    return;
                }

                try {
                    const chatRef = doc.ref.parent.parent;
                    if (!chatRef) {
                        await doc.ref.update({ status: "failed", error: "Invalid chat reference" });
                        return;
                    }

                    const chatSnap = await chatRef.get();
                    if (!chatSnap.exists) {
                        await doc.ref.update({ status: "failed", error: "Chat not found" });
                        return;
                    }

                    // âœ… IMPROVED PHONE FORMATTING
                    let phone = chatSnap.data().contactPhone;
                    phone = phone.replace(/\D/g, ''); // Remove non-digits

                    // Auto-add country code if missing
                    if (phone.length === 10) {
                        phone = '91' + phone; // Default to India
                    }

                    // Add WhatsApp suffix
                    if (!phone.includes('@')) {
                        phone = phone + "@s.whatsapp.net";
                    }

                    console.log(`ðŸ“¨ Sending to: ${phone}`);

                    let sent;
                    if (data.mediaUrl) {
                        // âœ… VALIDATE URL FIRST
                        try {
                            new URL(data.mediaUrl);
                        } catch (e) {
                            console.error(`âŒ Invalid media URL: "${data.mediaUrl}"`);
                            await doc.ref.update({ status: "failed", error: `Invalid media URL: ${data.mediaUrl}` });
                            return;
                        }

                        // âœ… Download media from R2 first, then send as buffer
                        console.log(`ðŸ“¥ Downloading media from R2: ${data.mediaUrl}`);
                        const response = await axios.get(data.mediaUrl, { responseType: 'arraybuffer' });
                        const buffer = Buffer.from(response.data);

                        const payload = { caption: data.text || "" };
                        if (data.mediaType === 'video') {
                            payload.video = buffer;
                        } else if (data.mediaType === 'document') {
                            payload.document = buffer;
                            payload.fileName = "File.pdf";
                            payload.mimetype = "application/pdf";
                        } else {
                            // Default to image
                            payload.image = buffer;
                        }
                        sent = await sock.sendMessage(phone, payload);
                        console.log(`âœ… Media sent: ${sent.key.id}`);
                    } else {
                        sent = await sock.sendMessage(phone, { text: data.text });
                        console.log(`âœ… Text sent: ${sent.key.id}`);
                    }

                    await doc.ref.update({
                        status: "sent",
                        sentAt: admin.firestore.FieldValue.serverTimestamp(),
                        waMessageId: sent.key.id
                    });

                    // âœ… UPDATE CHAT LAST MESSAGE
                    await chatRef.update({
                        lastMessage: data.text || "ðŸ“· Media",
                        updatedAt: admin.firestore.FieldValue.serverTimestamp()
                    });

                } catch (e) {
                    console.error("Send Error:", e.message);
                    await doc.ref.update({ status: "failed", error: e.message });
                }
            });
        });

    require("./broadcast_worker");